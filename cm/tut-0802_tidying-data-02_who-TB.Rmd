---
output: github_document
bibliography: "../manage/refs.bib" 
csl: "../manage/csl/journal-of-peace-research.csl"
---

```{r echo=FALSE}
library(knitr)
opts_knit$set(root.dir = "../")
opts_chunk$set(echo = TRUE, message = TRUE, collapse = TRUE, warning = TRUE, cache = TRUE, cache.path = "tut-08-cache/02-", fig.path = "tut-08-images/02-")
```


## tidying data case study

Preparation 

- Start a new script in your *practiceR* directory called *tut06_tidying-data-02_who-TB.R*  
- Start with your usual header  
  
        #  ---------------------------------------  
        #  tidying data
        #  world health organization 2016 TB data
        #  
        #  name  
        #  date  
        #  ---------------------------------------  

- Remember to install any packages you haven't used before  
  
```{r}
library(stringr)   # for str_replace()
library(tidyverse) # includes
#   # dplyr:  %>%, select(), mutate(), filter()
#   # tibble: rownames_to_column()
#   # tidyr:: gather(), spread()
#   # readr:  read_csv()

```





## source 

I adapted this study from [Data Tidying](http://garrettgman.github.io/tidying/), a chapter from the book [R for Data  Science](http://shop.oreilly.com/product/0636920034407.do) by Hadley Wickham and Garrett Grolemund. 

I'm following much of their work but have updated the dataset to use the 2016 [Case notifications](http://www.who.int/tb/country/data/download/en/) data from the World Health Organization. 

I downloaded the file called  from the WHO website and saved it to our course GitHub data file.
 
- Download the *TB_notifications_2017-09-10.csv* file from GitHub and save it to your course *data* directory. 





## first look

```{r}
# read the CSV file 
tb_data <- read_csv("data/TB_notifications_2017-09-10.csv")
```

From *glimpse()* below we see we have `r dim(tb_data)[1]` observations of `r dim(tb_data)[2]` variables. 

```{r}
glimpse(tb_data)
```

What years are included? This next line uses *select()* to isolate the year variable (column), then *%>%* determines the *unique()* values, transposes the vector *t()*, and *print()* them in the Console. 

We have all years from `r min(tb_data$year)` to `r max(tb_data$year)`. 

```{r}
select(tb_data, year) %>% unique() %>% t() %>% cat()
```





## the data encoding

A data dictionary on the [WHO tuberculosis website](http://www.who.int/tb/country/data/download/en/) describes the meaning of the variable names and how they encode additional data. 

We're interested in columns like `new_sp_f014` in which

- `new` indicates a new case of TB; the other possible level is `old`.  
- `sp` stands for a smear positive case type. The other possible levels are `rel` relapse; `ep`  extrapulmonary TB; `sn` smear negative (pulmonary TB that could not be diagnosed by a pulmonary smear). 
- `f` is female; the other possible levels are `m` male and `sexunk` sex unknown  
- `014` is the age group, from 0 to 14; other possible levels are `1524` 15-24 years old; `2534` 25-34 years old;; `3544` 35-44 years old;  `4554` 45-54 years old; `5564` 55-64 years old; and `65` 65 years old or older.





## select() 

The most distinctive characteristic of the variable names we want are the sex-age groupings. 

We use *dplyr::select()* to select columns with the *matches()* argument: select columns whose name includes the text shown (separated by the logical OR function `|`).    

```{r}
tb_data_wide <- tb_data %>% 
	select(country, year, 
	  matches('014|1524|2534|3544|4554|5564|65', ignore.case = TRUE))

glimpse(tb_data_wide)
```

This trims the data frame down to size. Now we have `r dim(tb_data_wide)[1]` observations of `r dim(tb_data_wide)[2]` variables.




## some diagnostics

After working my way through this data set further down, I discovered that the integer number of cases had become a character variable. 

It turns out that two of the columns in the original data file that should have contained only the integers (the number of TB cases) were coded as characters. 

In the current data frame only the first column `country` should be a character variable. To find the location of any others, I ran the following check. 

```{r}
cols2check   <- sapply(tb_data_wide, class)
cols2check   <- cols2check[cols2check == "character"]
cols2check   <- cols2check[names(cols2check) != "country"]
suspect_cols <- names(cols2check)

# these are my suspect columns
suspect_cols
```

Let's check the set of data entries in these two columns.  

```{r}
# what are the data entered in these columns? 
unique(tb_data_wide$new_sn_sexunk014)
unique(tb_data_wide$newrel_sexunk014)
```

OK. Except for the NA, these are all integers incorrectly encoded as character strings. To fix it, use *mutate()* and *as.numeric()*. 

```{r}
tb_data_wide <- tb_data_wide %>% 
	mutate(newrel_sexunk014 = as.numeric(newrel_sexunk014)) %>% 
	mutate(new_sn_sexunk014 = as.numeric(new_sn_sexunk014))
```










## gather() 

The first data tidying task is to move the coded column names into their own column with *gather()*. This will make it easy to separate the values combined in each code. The arguments of gather() are

*gather(df, "key col name", "value col name", cols to gather)*  

- *df* the name of the data frame being operated on  
- *"key col name"* the name in quotes is the new column name for gathering the previous column names  
- *"value col name"* the name in quotes is the new column name for gathering the data entries in the gathered columns.  
- *cols to gather* is the set of columns being gathered. Other columns remain as variables, repeated in the new data frame as often as needed.  

```{r}


who <- tb_data_wide %>%
	gather("code", "N", new_sp_m014:newrel_sexunk014, na.rm = TRUE)

glimpse(who)
```

So, in the *gather()* we just did, 

- *tb_data_wide* is the untidy data frame  
- *"code"* is the new column for gathering column names like  "new_sp_m014"  
- *"value"* is the new column for gathering the data values  
- *new_sp_m014:newrel_sexunk014* is the range of columns being gathered (col 3 through col 61)   

The new data frame *who* is in long form, with  `r dim(who)[1]` observations of `r dim(who)[2]` variables.

Check the codes before we separate them.

```{r}
select(who, code) %>% unique() %>% t() %>% cat()
```




## str_replace() 

The entry *newrel_xxx* is not encoded with an underscore between *new* and *rel* as in the other case types. To fix this, we recode the values in the *code* variable containing *newrel_xxx* to *new_rel_xxx* using *stringr::str_replace()* 


```{r}
who <- who %>% 
	mutate(code = stringr::str_replace(code, "newrel", "new_rel"))

# check again
select(who, code) %>% unique() %>% t() %>% cat()
```

Similarly, I'd like to change the unknown sex to a single letter *u*. 


```{r}
who <- who %>% 
	mutate(code = stringr::str_replace(code, "sexunk", "u"))

glimpse(who)
```




## separate() 

Though the data frame is in long form, it is still untidy. The variable *code* encodes four variables:  new_old, case_type, sex, and age. 

We use *separate()* to split these values at the underscores into three new variables. 

```{r}
who <- who %>% 
	separate(code, c("new_old", "case_type", "sex_age"), sep = "_")

glimpse(who)
```


Now we can separate *sex_age*. The `sep = 1` argument separates the character string after the first character, i.e., after the initial `f`, `m`, or `u`. (This is why I changed `sexunk` to `u`. ) 

```{r}
who <- who %>% 
	separate(sex_age, c("sex", "age_group"), sep = 1)

glimpse(who)
```


## sum all cases by country, year, and sex

Ignoring age group and summing all case types

```{r}
this_group  <- group_by(who, country, year, sex)
who1 <- dplyr::summarise(this_group, N = sum(N, na.rm = TRUE)) %>%
	as.data.frame()

glimpse(who1)
```


All countries

```{r fig.height = 30, fig.width = 10}
ggplot(who1, aes(x = year, y = N/1e+6, col = sex, group = sex)) +
	geom_line() +
	# geom_point() +
	facet_wrap(~reorder(country, -N), ncol = 10) +
	labs(x = "Source: World Health Organization (2017)", y = "In millions", title = "Number of annual cases of TB") +
	theme_light()
```


a subset 

```{r fig.width = 10}
who2 <- who1 %>% 
	dplyr::filter(country %in% c("India", "China", "South Africa", "Indonesia", "Bangladesh", "Germany", "United States of America", "Mexico", "Russian Federation")) %>% 
	dplyr::filter(sex != "u")

ggplot(who2, aes(x = year, y = N/1e+6, col = sex, group = sex)) +
	geom_line() +
	# geom_point(size = 2) +
	facet_wrap(~reorder(country, -N), ncol = 3) +
	labs(x = "Source: World Health Organization (2017)", y = "In millions", title = "Number of annual cases of TB") +
	theme_light()
```

