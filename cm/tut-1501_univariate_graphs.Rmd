---
title: displaying univariate data
output: 
  github_document:
    toc: TRUE
    toc_depth: 2
bibliography: "../manage/refs.bib" 
csl: "../manage/csl/journal-of-peace-research.csl"
---

```{r 1501, echo=FALSE}
library(knitr)
opts_knit$set(root.dir = "../")
opts_chunk$set(echo = TRUE, message = FALSE, collapse = TRUE, warning = FALSE, cache = TRUE, cache.path = "tut-15-cache/01-", fig.path = "tut-15-images/01-")
```

## data preparation

Always start your work session by launching the .Rproj file you created for this course. Using an R Project automatically sets the working directory to your course folder, making relative file paths easy to use.

- File $\rightarrow$ Recent projects $\rightarrow$ me447_visualizing-data.Rproj  
- Open a new R script called *tut15_gather_univariate.R*  
- Save it to your *practiceR* folder  
- Download the xlsx file *univariate_doumont_cases.xlsx* from the *data* directory on GitHub. 
- Save to your *data* directory. 

In the R script, type your usual header 

    #  ------------------------------------------
    #  gathering and tidying univariate data
    #
    #  name
    #  date
    #  ------------------------------------------

and add the usual knitr code chunk 

```
library(knitr)
opts_knit$set(root.dir = "../")
opts_chunk$set(echo = TRUE, messages = FALSE)
```




## gather and tidy univariate data

Housekeeping

```{r}
# housekeeping
rm(list = ls())
```

Packages

```{r}
# packages
library(tidyverse)
library(forcats)
library(readxl)
```

Read the xlsx file and display it

```{r}
# read the file
df1 <- read_excel('data/univariate_doumont_cases.xlsx')

# have a look
glimpse(df1)
```

It's small enough to print as a table

```{r}
# small enough to print
kable(df1)
```

The data are not tidy. We have one category (case number) and one measurement.

```{r}
# tidy the data
df2 <- df1 %>% 
	gather(case_number, measurement, case1:case4)

# check it
glimpse(df2)
```

Let's turn the case number into a factor. 

```{r}
# create a the known and fixed set of levels for the new factor variable 
case_levels <- c(
  "case1", "case2", "case3", "case4" 
  )

# create the factor variable using mutate() and factor() 
df3 <- df2 %>% 
    mutate(case_number = factor(case_number, levels = case_levels))

# check
glimpse(df3)
```

Then recode the factor for readability later. 

```{r}
df3 <- df3 %>% 
	mutate(case_number = fct_recode(case_number,
		"Case 1" = "case1", # new = old
		"Case 2" = "case2",
		"Case 3" = "case3",
		"Case 4" = "case4"
))

# check
glimpse(df3)
```

Write the tidy data to file. 

```{r}
write_csv(df3, 'data/univariate_doumont_cases.csv')
```

## design preparation

For your project of course, "gather-data" scripts would be in your *data* directory and "graph design" scripts would be in your *design* directory. But we'll save all tutorial scripts in the *practiceR* directory. 

- Open a new R script called *tut15_design_univariate.R*  
- Save it to your *practiceR* folder

In the R script, type your usual header 

    #  ------------------------------------------
    #  graphs of univariate data
    #
    #  name
    #  date
    #  ------------------------------------------

and add the usual knitr code chunk 

```
library(knitr)
opts_knit$set(root.dir = "../")
opts_chunk$set(echo = TRUE, messages = FALSE)
```
Housekeeping

```{r}
# housekeeping
rm(list = ls())
```

Packages

```{r}
# packages
library(tidyverse)
```

Read the CSV data file

```{r}
df1 <- read_csv('data/univariate_doumont_cases.csv')
```


## show all the data 

Make a dotplot of the cases. Each row will have as many dots as there are measurements by case number.

```{r}
ggplot(data = df1, aes(x = measurement, y = case_number)) +
	geom_point() +
	labs(y = "", x = "Distribution of measurement")
```

What we see is the distribution of a single variable conditioned by the category I called "case". If the data markers do not overprint too badly, this is an ideal approach to showing a distribution: we have not summarized it in any way. 








## box plots

To facilitate comparisons between the 4 cases, a box plot is probably your first and best alternative: the box plot (more precisely called a box and whisker plot) is a "5-value summary" of the data, showing the median and four quartiles plus outliers. 

```{r}
f2 <- ggplot(data = df1, aes(x = case_number, y = measurement)) +
	geom_boxplot() +
	labs(x = "", y = "Distribution of measurement")

f2
```

The default box plot orientation in *ggplot2* is vertical. To swap the axes, we use *coord_flip()*. 

```{r}
f3 <- f2 + 
	coord_flip() +
	labs(x = "", y = "Distribution of measurement")
f3
```

When comparing distributions, reorder use the median value. 

```{r}
f4 <- f3 + 
	aes(x = reorder(case_number, measurement, median), y = measurement) +
	labs(x = "", y = "Distribution of measurement")
f4
```

You can also add the data markers on top of the boxplot to show all the data and the 5-point summary. 

```{r}
f5 <- f4 + 
	geom_jitter(width = 0.02) +
	labs(x = "", y = "Distribution of measurement")
f5
```





## be skeptical of 2-value summaries

Let's create a commonly encountered "2-value summary" of distributed univariate data: means and standard deviations.

```{r}
this_group <- group_by(df1, case_number)
df2 <- summarize(
	this_group, 
	mean = mean(measurement), 
	sd = sd(measurement)
)


kable(df2)
```

Let's recall the original distribution

```{r}
f6 <- ggplot(data = df1, aes(x = measurement, y = case_number)) +
  geom_point() +
  labs(y = "", x = "Distribution of measurement") + 
	scale_x_continuous(limits = c(0, 25))

f6
```


Let's fade out the data and overlay the means $\pm$ 1 standard deviation
 
```{r}
ggplot() + 
  geom_point(data = df1
  	, aes(x = case_number, y = measurement), alpha = 0.3) +
  geom_linerange(data = df2
  	, aes(x = case_number, ymin = mean - sd, ymax = mean + sd), color = 'darkgoldenrod3', size = 1) +
	geom_point(data = df2
		, aes(x = case_number, y = mean), color = 'darkgoldenrod3', size = 2.5) +
	labs(x = "", y = "Distribution summary") + 
	scale_y_continuous(limits = c(0, 25)) + 
	coord_flip()
```

Of course if the author only showed you the 2-value summary (means and standard deviation), all you would see is this, 

 
```{r}
ggplot() + 
  geom_linerange(data = df2
  	, aes(x = case_number, ymin = mean - sd, ymax = mean + sd), color = 'darkgoldenrod3', size = 1) +
	geom_point(data = df2
		, aes(x = case_number, y = mean), color = 'darkgoldenrod3', size = 2.5) +
	labs(x = "", y = "Distribution summary") + 
	scale_y_continuous(limits = c(0, 25)) +
	coord_flip()
```


You would never know that the 4 cases had quite different distributions. 

Conclusion: Be skeptical if someone draws conclusions from means and standard deviations only. 


## histograms

I recommend box and whisker plots for comparing distributions, but histograms are occasionally useful. You can edit the *binwidth* argument to change the display (which is why histograms are subject to rhetorical malpractice).

```{r}
# histogram
ggplot(data = df1, aes(measurement)) +
	geom_histogram(binwidth = 1) +
	facet_grid(~case_number)
```

Or you can use a frequency polygon, sort of a connect-the-dots histogram. Again, bin width can be adjusted. 

```{r}
# frequency polygon
ggplot(data = df1, aes(measurement)) +
	geom_freqpoly(binwidth = 1) +
	facet_grid(~case_number)
```

Or you might try the kernel density estimate, a smoothed version of the histogram. You can tweak the contours by changing the *adjust* argument. 

```{r}
ggplot(data = df1, aes(measurement)) +
	geom_density(adjust = 1, fill = 'darkgoldenrod3', alpha = 0.3) +
	facet_grid(~case_number)
```

You could try overlaying the cases in one panel

```{r}
ggplot(data = df1, aes(measurement, fill = case_number)) +
	geom_density(adjust = 1, alpha = 0.5)
```

With too many cases overlapping, visual comparisons become more difficult. 




## exercise

I've adapted this exercise from [@Unwin2015]. 

- Install the package *GDAdata* 

```{r}
# use the SpeedSki data from the GDAdata package
library(tidyverse)
library(GDAdata)
data(SpeedSki)
```

The *SpeedSki* data contains the speeds of competitors in the 2011 World Speed Skiing Championships by event and sex. The speed data are univariate: the single measured quantity is speed. 

1. Display a histogram of speeds conditioned by sex.  
2. Draw the same data as a boxplot.  What tentative conclusions do you draw? 
3. Repeat the histogram, but add facets conditioned by sex and event. 
4. Draw the same data as a box plot. What conclusions do you make now? 


```{r include = FALSE}
ggplot(data = SpeedSki, aes(x = Speed, fill = Sex)) +
	geom_histogram(binwidth = 2.5, color = "gray40") + 
	facet_wrap(~Sex, ncol = 1) +
	theme(legend.position = "none") +
	scale_fill_manual(values = c("black", "darkgoldenrod3")) +
	xlim(160, 220) +
	ylim(0, 10) +
	labs(x = "Speed (km/hr)", y = "")

ggplot(data = SpeedSki, aes(x = reorder(Sex, Speed, median), y = Speed)) +
	geom_boxplot() + 
	labs(x = "", y = "Speed (km/hr)") +
	coord_flip()

ggplot(data = SpeedSki, aes(x = Speed, fill = Sex)) +
	geom_histogram(binwidth = 2.5, color = "gray40") + 
	facet_grid(Sex ~ Event) +
	theme(legend.position = "none") +
	scale_fill_manual(values = c("black", "darkgoldenrod3")) +
	xlim(160, 220) +
	ylim(0, 8) +
	labs(x = "Speed (km/hr)", y = "")


f6 <- ggplot(data = SpeedSki, aes(x = reorder(Sex, Speed, median), y = Speed, fill = Sex)) +
	geom_boxplot(color = "darkgoldenrod4") + 
	labs(x = "", y = "Speed (km/hr)") +
	facet_wrap(~ reorder(Event, -Speed, median), ncol = 1) +
	scale_fill_manual(values = c("black", "darkgoldenrod2")) +
	theme(legend.position = "none") +
	coord_flip()

# start the image PNG device
png(filename = 'cm/tut-15-images/tut15_boxplot.png'
    , width  = 6.5
    , height = 4
    , units  = 'in'
    , res = 300
    )

    # print the figure to PNG
    print(f6)

# close the device: necessary
dev.off() 
f6
```


[Click here](tut-15-images/tut15_boxplot.png) to see my solution to question 4. 

## bibliography 

<div id="refs"></div>
  
---

[main page](../README.md)<br>
[topics page](../README-by-topic.md)
